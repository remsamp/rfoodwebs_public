newdata[newdata$LocationName=="NMMP 605 Celtic Deep" | newdata$LocationName=="NMMP 605 Celtic Deep 2005",1:20]
rm(list = ls())#
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] != "P" & newdata[, #
	i] != "-"))) > 0)#
# so the intersection of that is not empty, which means there are mixture of Ps and actual numbers. See explanation above. for now convert to strings and will#
# decide what to do in terms of converting "P" into a number later on. #
#
# for (i in 19:ncol(newdata)) {#
	# inter <- newdata[, i]#
	# inter1 <- rep(0, nrow(newdata))#
	# inter1[which(inter == "-")] <- 0#
	# inter1[which(inter == "P")] <- 1#
	# inter1[which(inter != "P" & inter != "-")] <- as.numeric(inter[which(inter != "P" & inter != "-")])#
	# newdata[, i] <- inter1#
	# print(i)#
# }#
# ab <- sapply(c(19:ncol(newdata)), function(i) sum(newdata[, i], na.rm = T))#
# levels(newdata$SurveyCode) #
# length(levels(newdata$SurveyCode))# 19 different surveys, which is the majority of the ones I had identified#
#
# library(ggplot2)#
# library(ggmap)#
# long <- as.numeric(as.character(newdata$Longitude))#
# lat <- as.numeric(as.character(newdata$Latitude))#
# mydat <- data.frame(long = long, lat = lat)#
# mymap <- get_map(location = c(-5, 53.5), "satellite", zoom = 6, scale = "auto", col = "bw")#
# p <- ggmap(mymap) + geom_point(data = mydat, aes(x = long, y = lat))#
# p#
# coordtype <- newdata$CoordinateType#
#
# idx <- (which(ab > 1) + 18)#
# sub <- newdata[, c(1:18, idx)]#
# meanr <- function(x) mean(x, na.rm = T)#
# sapply(c(19:ncol(sub)), function(i) tapply(sub[, i], factor(sub$SurveyCode), meanr))#
# ok this seems to be good. email to get more data. ask perhaps about the zeros: are species always looked for? is an absence of data meaning the species was not looked for or was searched for but not found#
# xx <- newdata[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
# xxx <- xx[which(xx$Latitude == "<null>" | xx$Longitude == "<null>"), ]#
# xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", "StartDate", "SourceName")]#
# write.csv(xxx, "~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/coordinates_for_survey.csv", #
	# row.names = F)#
# Lune Deep has so far no coordinate, but the others have target coordinates i.e. a single couple of coordinates for the station (not one per replicate). they are very close by so should be ok. #
# NMMP605 51.25 -6#
# NMMP715 53.5 -3.706333#
# NMMP805 54 -3.833#
# NMMP655 52.35833 -4.17500#
# NMMP815   54.066700      -5.5#
# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
# CSEMP redesign 20A  35E5(int) 53° 6.25’N     4° 33.76’W#
# CSEMP redesign 10A  MUSD3    52° 18.73’N  4° 13.46’W#
# Lune Deep (approximate location) 53° 57’ 14”, -3° 5’ 50”.#
#
# fill in the coordinates#
# celtic deep survey: actually three different survey names corresponding to 3 years of data. same location??#
newdata$Latitude[newdata$SurveyCode == "CEND1110605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1110605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "END905605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "END905605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1009605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1110715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CEND1110715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1110805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1110805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00655"] <- "52.35833" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00655"] <- "-4.17500"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00815"] <- "54.066700"#
newdata$Longitude[newdata$SurveyCode == "CIR4B00815"] <- "-5.5"#
# # # # ------------------------------------------- #
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "18A"] <- "52.68467"# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07"& newdata$SampleCode == "18A"] <- "-5.012167"#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "53.10417"# 53° 6.25’N     #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "-4.562667"# 4° 33.76’W#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "52.31217"# 52° 18.73’N  #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "-4.224333"# 4° 13.46’W#
#
# Lune Deep#
newdata$Latitude[newdata$SurveyCode == "LDP96"] <- "53.95389"# 53° 57’ 14”#
newdata$Longitude[newdata$SurveyCode == "LDP96"] <- "-3.097222"# -3° 5’ 50”
newdata$Latitude
newdata[1:50, 1:20]
rm(list = ls())#
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] != "P" & newdata[, #
	i] != "-"))) > 0)#
# so the intersection of that is not empty, which means there are mixture of Ps and actual numbers. See explanation above. for now convert to strings and will#
# decide what to do in terms of converting "P" into a number later on. #
#
# for (i in 19:ncol(newdata)) {#
	# inter <- newdata[, i]#
	# inter1 <- rep(0, nrow(newdata))#
	# inter1[which(inter == "-")] <- 0#
	# inter1[which(inter == "P")] <- 1#
	# inter1[which(inter != "P" & inter != "-")] <- as.numeric(inter[which(inter != "P" & inter != "-")])#
	# newdata[, i] <- inter1#
	# print(i)#
# }#
# ab <- sapply(c(19:ncol(newdata)), function(i) sum(newdata[, i], na.rm = T))#
# levels(newdata$SurveyCode) #
# length(levels(newdata$SurveyCode))# 19 different surveys, which is the majority of the ones I had identified#
#
# library(ggplot2)#
# library(ggmap)#
# long <- as.numeric(as.character(newdata$Longitude))#
# lat <- as.numeric(as.character(newdata$Latitude))#
# mydat <- data.frame(long = long, lat = lat)#
# mymap <- get_map(location = c(-5, 53.5), "satellite", zoom = 6, scale = "auto", col = "bw")#
# p <- ggmap(mymap) + geom_point(data = mydat, aes(x = long, y = lat))#
# p#
# coordtype <- newdata$CoordinateType#
#
# idx <- (which(ab > 1) + 18)#
# sub <- newdata[, c(1:18, idx)]#
# meanr <- function(x) mean(x, na.rm = T)#
# sapply(c(19:ncol(sub)), function(i) tapply(sub[, i], factor(sub$SurveyCode), meanr))#
# ok this seems to be good. email to get more data. ask perhaps about the zeros: are species always looked for? is an absence of data meaning the species was not looked for or was searched for but not found#
# xx <- newdata[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
# xxx <- xx[which(xx$Latitude == "<null>" | xx$Longitude == "<null>"), ]#
# xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", "StartDate", "SourceName")]#
# write.csv(xxx, "~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/coordinates_for_survey.csv", #
	# row.names = F)#
# Lune Deep has so far no coordinate, but the others have target coordinates i.e. a single couple of coordinates for the station (not one per replicate). they are very close by so should be ok. #
# NMMP605 51.25 -6#
# NMMP715 53.5 -3.706333#
# NMMP805 54 -3.833#
# NMMP655 52.35833 -4.17500#
# NMMP815   54.066700      -5.5#
# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
# CSEMP redesign 20A  35E5(int) 53° 6.25’N     4° 33.76’W#
# CSEMP redesign 10A  MUSD3    52° 18.73’N  4° 13.46’W#
# Lune Deep (approximate location) 53° 57’ 14”, -3° 5’ 50”.#
#
# fill in the coordinates#
# celtic deep survey: actually three different survey names corresponding to 3 years of data. same location??#
newdata$Latitude[newdata$SurveyCode == "CEND1110605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1110605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "END905605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "END905605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1009605"] <- "-6"#
#
# same here, two different surveys for NMMP 715#
newdata$Latitude[newdata$SurveyCode == "CEND1110715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CEND1110715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1110805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1110805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00655"] <- "52.35833" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00655"] <- "-4.17500"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00815"] <- "54.066700"#
newdata$Longitude[newdata$SurveyCode == "CIR4B00815"] <- "-5.5"
newdata$Latitude
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "18A"] <- "52.68467"# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07"& newdata$SampleCode == "18A"] <- "-5.012167"#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "53.10417"# 53° 6.25’N     #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "-4.562667"# 4° 33.76’W#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "52.31217"# 52° 18.73’N  #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "-4.224333"# 4° 13.46’W#
#
# Lune Deep#
newdata$Latitude[newdata$SurveyCode == "LDP96"] <- "53.95389"# 53° 57’ 14”#
newdata$Longitude[newdata$SurveyCode == "LDP96"] <- "-3.097222"# -3° 5’ 50”
newdata$Latitude
newdata[newdata$Latitude=="<null>", 1:20]
rm(list = ls())#
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] != "P" & newdata[, #
	i] != "-"))) > 0)#
# so the intersection of that is not empty, which means there are mixture of Ps and actual numbers. See explanation above. for now convert to strings and will#
# decide what to do in terms of converting "P" into a number later on. #
#
# for (i in 19:ncol(newdata)) {#
	# inter <- newdata[, i]#
	# inter1 <- rep(0, nrow(newdata))#
	# inter1[which(inter == "-")] <- 0#
	# inter1[which(inter == "P")] <- 1#
	# inter1[which(inter != "P" & inter != "-")] <- as.numeric(inter[which(inter != "P" & inter != "-")])#
	# newdata[, i] <- inter1#
	# print(i)#
# }#
# ab <- sapply(c(19:ncol(newdata)), function(i) sum(newdata[, i], na.rm = T))#
# levels(newdata$SurveyCode) #
# length(levels(newdata$SurveyCode))# 19 different surveys, which is the majority of the ones I had identified#
#
# library(ggplot2)#
# library(ggmap)#
# long <- as.numeric(as.character(newdata$Longitude))#
# lat <- as.numeric(as.character(newdata$Latitude))#
# mydat <- data.frame(long = long, lat = lat)#
# mymap <- get_map(location = c(-5, 53.5), "satellite", zoom = 6, scale = "auto", col = "bw")#
# p <- ggmap(mymap) + geom_point(data = mydat, aes(x = long, y = lat))#
# p#
# coordtype <- newdata$CoordinateType#
#
# idx <- (which(ab > 1) + 18)#
# sub <- newdata[, c(1:18, idx)]#
# meanr <- function(x) mean(x, na.rm = T)#
# sapply(c(19:ncol(sub)), function(i) tapply(sub[, i], factor(sub$SurveyCode), meanr))#
# ok this seems to be good. email to get more data. ask perhaps about the zeros: are species always looked for? is an absence of data meaning the species was not looked for or was searched for but not found#
# xx <- newdata[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
# xxx <- xx[which(xx$Latitude == "<null>" | xx$Longitude == "<null>"), ]#
# xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", "StartDate", "SourceName")]#
# write.csv(xxx, "~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/coordinates_for_survey.csv", #
	# row.names = F)#
# Lune Deep has so far no coordinate, but the others have target coordinates i.e. a single couple of coordinates for the station (not one per replicate). they are very close by so should be ok. #
# NMMP605 51.25 -6#
# NMMP715 53.5 -3.706333#
# NMMP805 54 -3.833#
# NMMP655 52.35833 -4.17500#
# NMMP815   54.066700      -5.5#
# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
# CSEMP redesign 20A  35E5(int) 53° 6.25’N     4° 33.76’W#
# CSEMP redesign 10A  MUSD3    52° 18.73’N  4° 13.46’W#
# Lune Deep (approximate location) 53° 57’ 14”, -3° 5’ 50”.#
#
# fill in the coordinates#
# celtic deep survey: actually three different survey names corresponding to 3 years of data. same location??#
newdata$Latitude[newdata$SurveyCode == "CEND1110605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1110605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "END905605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "END905605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1009605"] <- "-6"#
#
# same here, two different surveys for NMMP 715#
newdata$Latitude[newdata$SurveyCode == "CEND1110715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CEND1110715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00715"] <- "-3.706333"#
#
# same for 805, 4 surveys#
newdata$Latitude[newdata$SurveyCode == "CEND1110805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1110805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1009805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "END905805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "END905805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00655"] <- "52.35833" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00655"] <- "-4.17500"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00815"] <- "54.066700"#
newdata$Longitude[newdata$SurveyCode == "CIR4B00815"] <- "-5.5"
newdata$Latitude
# # # # ------------------------------------------- #
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "18A"] <- "52.68467"# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07"& newdata$SampleCode == "18A"] <- "-5.012167"#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "53.10417"# 53° 6.25’N     #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "-4.562667"# 4° 33.76’W#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "52.31217"# 52° 18.73’N  #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "-4.224333"# 4° 13.46’W#
#
# Lune Deep#
newdata$Latitude[newdata$SurveyCode == "LDP96"] <- "53.95389"# 53° 57’ 14”#
newdata$Longitude[newdata$SurveyCode == "LDP96"] <- "-3.097222"# -3° 5’ 50”
newdata$Latitude
data2 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_2.csv", header = F)#
newdata2 <- data.frame(t(data2[, c(4:ncol(data2))]))#
names(newdata2) <- as.character(data2[, 3])#
id <- as.character(data2[, 2])#
#
sapply(c(1:ncol(newdata2)),function(i)class(newdata2[,i]))
?ls
rm(list=ls(all=TRUE))
rm(list=ls(all=TRUE))#
#
# Load required libraries#
require(deSolve)#
require(lattice)
state.compmodel
runfunction <- function( y, times, func, params ) {#
out.c <- ode(y = y, times = times, func = func, parms = params )#
return( out.c)#
#
}#
#
# Model parameters#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.35 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
delta.t <- times[2] - times[1]
state.compmodel <- matrix( c( c(round(runif(100, min=0, max=50), round(runif(100, min=200, max=250) , round(runif(100, min=400, max=450)), rep( 0.5, 300 ), rep( 0.5, 300 ) ) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )
state.compmodel <- matrix( c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 ) ) , ncol = 3 )# 0.01
c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450)))
matrix( c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 ) , ncol = 3 )
matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.35 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
delta.t <- times[2] - times[1]#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(2, 2), mar =c(3,3,2,1))#
plot(out1[,2], ty="l")#
plot(out1[,3], ty = "l")#
plot(out1[,4], ty = "l")#
plot(out1[,4],out1[,3], ty = "l")
simulate_competition <- function( t, state, parameters){#
#
with(as.list(c(state,parameters)),{#
	# alpha1 is effect of competitor 1 on competitor 2#
	# alpha2 is effect of competitor 2 on competitor 1#
    dR  <- (- beta1) * (B1 - alpha2 * B2) * R -  beta2 * (B2 - alpha1 * B1) * R + renewal * R#
    dB1 <- gamma1 * beta1 * (B1 - alpha2 * B2) * R - d1 * B1 # competitor 1#
    dB2 <- gamma2 * beta2 * (B2 - alpha1 * B1) * R - d2 * B2 # competitor 2#
	if(B1 <= 0) dB1 <- 0#
	# if(B2 <= 0) dB2 <- 0#
    list(c(dR,dB1,dB2))#
  })#
#
}
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.35 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
delta.t <- times[2] - times[1]#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(2, 2), mar =c(3,3,2,1))#
plot(out1[,2], ty="l")#
plot(out1[,3], ty = "l")#
plot(out1[,4], ty = "l")#
plot(out1[,4],out1[,3], ty = "l")
state.compmodel
plot(out1[state.compmodel$R >=0 & state.compmodel$R <= 50,4],out1[state.compmodel$R >=0 & state.compmodel$R <= 50,3], ty = "l")
state.compmodel$R >=0
state.compmodel
names(state.compmodel)
plot(out1[state.compmodel$R >=0 & state.compmodel$R <= 50,4],out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3], ty = "l")
out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3]
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,4],out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3], ty = "l")
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,4],out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3], ty = "p")
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 250,4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 250,3], ty = "p")
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,3], ty = "p")
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.3 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
delta.t <- times[2] - times[1]#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(2, 2), mar =c(3,3,2,1))
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,4],out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3], ty = "p")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 250,4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 250,3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,3], ty = "p")
plot(out1[,4],out1[,3], ty = "p")
plot(rep(1,300), out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p")
plot(rep(1,100), out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p")
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p")
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,5), ylim=c(0, 500))#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,4), ylim=c(0, 500), ylab = "Resource availability at plot level")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.3 , d1 = 0.005, d2 = 0.005, renewal = 0.005) #
# pattern is correct for alpha2 = 0.3, d = 0.005 and renewal = 0.001#
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(2, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,4],out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,3], ty = "p")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250,4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250,3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,3], ty = "p")#
plot(out1[,4],out1[,3], ty = "p")
# simulate something different, with the amount of resources varying around a mean, that changes along the gradient#
# Model parameters#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.25 , d1 = 0.005, d2 = 0.005, renewal = 0.005) #
# pattern is correct for alpha2 = 0.3, d = 0.005 and renewal = 0.001#
# pattern is not correct for alpha2 = 0.3, d = 0.005 and renewal = 0.005, because alpha2 is too large with the associated added resource#
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=200, max=250)) , round(runif(100, min=400, max=450))), rep( 0.5, 300 ), rep( 0.5, 300 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(2, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p")#
plot(out1[,4],out1[,3], ty = "p")
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=100, max=150)) ,round(runif(100, min=200, max=250)) , round(runif(100, min=300, max=350)) ,round(runif(100, min=400, max=450))), rep( 0.5, 500 ), rep( 0.5, 500 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )
par(mfrow = c(3, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p")#
plot(out1[,4],out1[,3], ty = "p")
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")
par(mfrow = c(3, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p")#
plot(out1[,4],out1[,3], ty = "p")#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,4), ylim=c(0, 500), ylab = "Resource availability at plot level")
par(mfrow = c(3, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p")#
plot(out1[,4],out1[,3], ty = "p")
par(mfrow = c(3, 2), mar =c(3,3,2,1))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
par(mfrow = c(3, 2), mar =c(3,3,2,1), mgp = c(1.5, 0.5, 0))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.3 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
# pattern is correct for alpha2 = 0.3, d = 0.005 and renewal = 0.001#
# pattern is not correct for alpha2 = 0.3, d = 0.005 and renewal = 0.005, because alpha2 is too large with the associated added resource#
#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=100, max=150)) ,round(runif(100, min=200, max=250)) , round(runif(100, min=300, max=350)) ,round(runif(100, min=400, max=450))), rep( 0.5, 500 ), rep( 0.5, 500 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(3, 2), mar =c(3,3,2,1), mgp = c(1.5, 0.5, 0))#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=100, max=150)) ,round(runif(100, min=200, max=250)) , round(runif(100, min=300, max=350)) ,round(runif(100, min=400, max=450)) ,round(runif(100, min=500, max=550))), rep( 0.5, 600 ), rep( 0.5, 600 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(4, 2), mar =c(3,3,2,1), mgp = c(1.5, 0.5, 0))
par(mfrow = c(4, 2), mar =c(3,3,2,1), mgp = c(1.5, 0.5, 0))#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
par(mfrow = c(4, 2), mar =c(2,3,2,1), mgp = c(1.5, 0.5, 0))#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")#
#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
par(mfrow = c(4, 2), mar =c(2.5,3,2,1), mgp = c(1.5, 0.5, 0))#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")#
#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level", xlab = "environmental gradient")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")#
#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
par(mfrow = c(4, 2), mar =c(2.5,3,2,1), mgp = c(1.5, 0.5, 0))#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level", xlab = "Site")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")#
#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.06 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=0, max=1000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
state.compmodel <- matrix( c(c(round(runif(1000, min=2000, max=3000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
abline(0, 1)
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.3 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
# pattern is correct for alpha2 = 0.3, d = 0.005 and renewal = 0.001. best so far#
# pattern is not correct for alpha2 = 0.3, d = 0.005 and renewal = 0.005, because alpha2 is too large with the associated added resource#
# pattern is correct for alpha2 = 0.25, d = 0.005 and renewal = 0.005, but not as good as first one above#
# Set the time steps#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
#
state.compmodel <- matrix( c(c(round(runif(100, min=0, max=50)), round(runif(100, min=100, max=150)) ,round(runif(100, min=200, max=250)) , round(runif(100, min=300, max=350)) ,round(runif(100, min=400, max=450)) ,round(runif(100, min=500, max=550))), rep( 0.5, 600 ), rep( 0.5, 600 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
par(mfrow = c(4, 2), mar =c(2.5,3,2,1), mgp = c(1.5, 0.5, 0))#
#
# this is what we expected#
plot(rep(1,100), state.compmodel[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50,1], ty="p", xlim = c(0,6), ylim=c(0, 600), ylab = "Resource availability at plot level", xlab = "Site")#
points(rep(2,100), state.compmodel[state.compmodel[, 1] >= 100 & state.compmodel[, 1] <= 150,1], ty="p")#
points(rep(3,100), state.compmodel[state.compmodel[, 1] >= 200 & state.compmodel[, 1] <= 250,1], ty="p")#
points(rep(4,100), state.compmodel[state.compmodel[, 1] >= 300 & state.compmodel[, 1] <= 350,1], ty="p")#
points(rep(5,100), state.compmodel[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450,1], ty="p")#
points(rep(6,100), state.compmodel[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550,1], ty="p")#
#
plot(out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 4], out1[state.compmodel[, 1] >=0 & state.compmodel[, 1] <= 50, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 4],out1[state.compmodel[, 1] >=100 & state.compmodel[, 1] <= 150, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 4],out1[state.compmodel[, 1] >=200 & state.compmodel[, 1] <= 250, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 4],out1[state.compmodel[, 1] >=300 & state.compmodel[, 1] <= 350, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 4],out1[state.compmodel[, 1] >= 400 & state.compmodel[, 1] <= 450, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 4],out1[state.compmodel[, 1] >= 500 & state.compmodel[, 1] <= 550, 3], ty = "p", ylab = "species 1", xlab = "species 2")#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")
quartz()#
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.06 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=10000, max=11000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2", ylim =c (0, 10), xlim = c(0, 10))
abline(0, 1)
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2", ylim =c (4, 6), xlim = c(4, 6))
abline(0, 1)
state.compmodel <- matrix( c(c(round(runif(1000, min=100000, max=101000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2", ylim =c (4, 6), xlim = c(4, 6))#
abline(0, 1)
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.001) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=100000, max=101000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.002) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=100000, max=101000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.005) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=100000, max=101000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.05) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=0, max=1000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.1) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=0, max=1000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
out1
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.5) #
#
state.compmodel <- matrix( c(c(round(runif(1000, min=0, max=1000))), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
out1
state.compmodel
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.5) #
#
state.compmodel <- matrix( c(seq(0, 1000, by = 1), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.5) #
#
state.compmodel <- matrix( c(seq(1, 1000, by = 1), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
out1
n.times = 1000#
times <- seq( 0, 500, length = n.times)#
parameters <- c( beta1 = 0.005, gamma1 = 0.01 , beta2 = 0.005, gamma2 = 0.01, alpha1 = 0.05, alpha2 = 0.075 , d1 = 0.005, d2 = 0.005, renewal = 0.5) #
#
state.compmodel <- matrix( c(seq(5001, 6000, by = 1), rep( 0.5, 1000 ), rep( 0.5, 1000 )) , ncol = 3 )# 0.01#
colnames( state.compmodel ) <- c( "R", "B1", "B2" )#
out1 <- t( apply( state.compmodel, 1, function(x) runfunction( y = x, times = times, func = simulate_competition, params = parameters )[n.times,] ) )#
plot(out1[,4],out1[,3], ty = "p", ylab = "species 1", xlab = "species 2")#
abline(0, 1)
out1
rm(list = ls())#
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] != "P" & newdata[, #
	i] != "-"))) > 0)#
# so the intersection of that is not empty, which means there are mixture of Ps and actual numbers. See explanation above. for now convert to strings and will#
# decide what to do in terms of converting "P" into a number later on. #
#
# for (i in 19:ncol(newdata)) {#
	# inter <- newdata[, i]#
	# inter1 <- rep(0, nrow(newdata))#
	# inter1[which(inter == "-")] <- 0#
	# inter1[which(inter == "P")] <- 1#
	# inter1[which(inter != "P" & inter != "-")] <- as.numeric(inter[which(inter != "P" & inter != "-")])#
	# newdata[, i] <- inter1#
	# print(i)#
# }#
# ab <- sapply(c(19:ncol(newdata)), function(i) sum(newdata[, i], na.rm = T))#
# levels(newdata$SurveyCode) #
# length(levels(newdata$SurveyCode))# 19 different surveys, which is the majority of the ones I had identified#
#
# library(ggplot2)#
# library(ggmap)#
# long <- as.numeric(as.character(newdata$Longitude))#
# lat <- as.numeric(as.character(newdata$Latitude))#
# mydat <- data.frame(long = long, lat = lat)#
# mymap <- get_map(location = c(-5, 53.5), "satellite", zoom = 6, scale = "auto", col = "bw")#
# p <- ggmap(mymap) + geom_point(data = mydat, aes(x = long, y = lat))#
# p#
# coordtype <- newdata$CoordinateType#
#
# idx <- (which(ab > 1) + 18)#
# sub <- newdata[, c(1:18, idx)]#
# meanr <- function(x) mean(x, na.rm = T)#
# sapply(c(19:ncol(sub)), function(i) tapply(sub[, i], factor(sub$SurveyCode), meanr))#
# ok this seems to be good. email to get more data. ask perhaps about the zeros: are species always looked for? is an absence of data meaning the species was not looked for or was searched for but not found#
# xx <- newdata[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
# xxx <- xx[which(xx$Latitude == "<null>" | xx$Longitude == "<null>"), ]#
# xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", "StartDate", "SourceName")]#
# write.csv(xxx, "~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/coordinates_for_survey.csv", #
	# row.names = F)#
# Lune Deep has so far no coordinate, but the others have target coordinates i.e. a single couple of coordinates for the station (not one per replicate). they are very close by so should be ok. #
# NMMP605 51.25 -6#
# NMMP715 53.5 -3.706333#
# NMMP805 54 -3.833#
# NMMP655 52.35833 -4.17500#
# NMMP815   54.066700      -5.5#
# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
# CSEMP redesign 20A  35E5(int) 53° 6.25’N     4° 33.76’W#
# CSEMP redesign 10A  MUSD3    52° 18.73’N  4° 13.46’W#
# Lune Deep (approximate location) 53° 57’ 14”, -3° 5’ 50”.#
#
# fill in the coordinates#
# celtic deep survey: actually three different survey names corresponding to 3 years of data. same location??#
newdata$Latitude[newdata$SurveyCode == "CEND1110605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1110605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "END905605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "END905605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1009605"] <- "-6"#
#
# same here, two different surveys for NMMP 715#
newdata$Latitude[newdata$SurveyCode == "CEND1110715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CEND1110715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00715"] <- "-3.706333"#
#
# same for 805, 4 surveys#
newdata$Latitude[newdata$SurveyCode == "CEND1110805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1110805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1009805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "END905805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "END905805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00655"] <- "52.35833" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00655"] <- "-4.17500"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00815"] <- "54.066700"#
newdata$Longitude[newdata$SurveyCode == "CIR4B00815"] <- "-5.5"#
# # # # ------------------------------------------- #
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "18A"] <- "52.68467"# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07"& newdata$SampleCode == "18A"] <- "-5.012167"#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "53.10417"# 53° 6.25’N     #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "-4.562667"# 4° 33.76’W#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "52.31217"# 52° 18.73’N  #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "-4.224333"# 4° 13.46’W#
#
# Lune Deep#
newdata$Latitude[newdata$SurveyCode == "LDP96"] <- "53.95389"# 53° 57’ 14”#
newdata$Longitude[newdata$SurveyCode == "LDP96"] <- "-3.097222"# -3° 5’ 50”
data2 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_2.csv", header = F)#
newdata2 <- data.frame(t(data2[, c(4:ncol(data2))]))#
names(newdata2) <- as.character(data2[, 3])#
id <- as.character(data2[, 2])#
#
sapply(c(1:ncol(newdata2)),function(i)class(newdata2[,i]))
for (i in 19:ncol(newdata2)) newdata2[, i] <- as.character(newdata2[, i])
newdata2$Latitude<- as.character(newdata2$Latitude)#
newdata2$Longitude <- as.character(newdata2$Longitude)
colonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] != "P" & newdata[, #
	i] != "-"))) > 0)
colonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] != "P" & newdata[, i] != "-"))) > 0)
warnings()
colonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] == "P"))) > 0)
noncolonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] != "P" & newdata2[, i] != "-"))) > 0)
levels(factor(newdata2$SurveyCode)) # 20 different surveys
xx <- newdata2[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
xxx <- xx[which(as.character(xx$Latitude) == "<null>"), ]
dim(xxx)
xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title",
"StartDate", "SourceName")]
dim(xxx)
head(xxx)
head(newdata)
write.csv(xxx, "~/Desktop/coordinates_for_survey_2.csv", row.names = F)
data3 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_3rd_batch/DataforREMI_3rd batch.csv", header = F)#
newdata3 <- data.frame(t(data3[, c(4:ncol(data3))]))
names(newdata3) <- as.character(data3[, 3])#
id <- as.character(data3[, 2])
data3 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_3rd_batch/DataforREMI_3rd batch.csv", header = F)
data3[1:10, 1:10]
data2[1:10, 1:10]
data3 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_3rd_batch/DataforREMI_3rd batch.csv", header = F)#
newdata3 <- data.frame(t(data3[, c(3:ncol(data3))]))#
names(newdata3) <- as.character(data3[, 2])#
id <- as.character(data3[, 1])
newdata3[1:10, 1:10]
sapply(c(1:ncol(newdata3)),function(i)class(newdata3[,i]))
newdata3[1:10, 1:20]
for (i in 19:ncol(newdata3)) newdata3[, i] <- as.character(newdata3[, i])
newdata3[1:10, 1:20]
newdata3[1:10, 20]
newdata3$Latitude<- as.character(newdata3$Latitude)#
newdata3$Longitude <- as.character(newdata3$Longitude)
colonial <- which(sapply(c(19:ncol(newdata3)), function(i) length(which(newdata3[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata3)), function(i) length(which(newdata3[, i] != "P" & newdata3[, i] != ""))) > 0)
length(levels(factor(newdata3$SurveyCode))) # 20 different surveys
xx <- newdata3[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
xxx <- xx[which(as.character(xx$Latitude) == "<null>"), ]#
xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", #
	"StartDate", "SourceName")]
head(xxx)
levels(xxx$SurveyCode)
length(levels(xxx$SurveyCode))
newdata3$latitude
newdata3$Latitude
newdata3$Longitude
newdata3[,c("Longitude", "latitude")]
newdata3[,c("Longitude", "Latitude")]
newdata3[,c("SurveyCode", "Longitude", "Latitude")]
length(levels(factor(xxx$SurveyCode)))
write.csv(xxx, "~/Desktop/coordinates_for_survey_3.csv", row.names = F)
data4 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_4th_batch/DataforREMI2ndand3rdBatch.csv")
newdata4 <- data.frame(t(data4[, c(3:ncol(data4))])) # eliminate the first row which contains a comment
names(newdata4) <- as.character(data4[, 2])
id <- as.character(data4[, 1])
newdata4[1:10, 1:10]
sapply(c(1:ncol(newdata4)),function(i)class(newdata4[,i]))
levels(factor(newdata4$SurveyCode)) # 50 different surveys
length(levels(factor(newdata4$SurveyCode))) # 50 different surveys
sapply(c(1:ncol(newdata4)),function(i)class(newdata4[,i]))
for (i in 19:ncol(newdata4)) newdata4[, i] <- as.character(newdata4[, i])
newdata4$Latitude<- as.character(newdata4$Latitude)#
newdata4$Longitude <- as.character(newdata4$Longitude)
newdata4[1:10, 1:10]
newdata4[1:10, 1:20]
colonial <- which(sapply(c(19:ncol(newdata4)), function(i) length(which(newdata4[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata4)), function(i) length(which(newdata4[, i] != "P" & newdata3[, i] != ""))) > 0)
colonial <- which(sapply(c(19:ncol(newdata4)), function(i) length(which(newdata4[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata4)), function(i) length(which(newdata4[, i] != "P" & newdata4[, i] != ""))) > 0)
length(levels(factor(newdata4$SurveyCode))) # 26 different surveys
xx <- newdata4[, c(1:18)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
xxx <- xx[which(as.character(xx$Latitude) == "<null>"), ]#
xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", #
	"StartDate", "SourceName")]#
length(levels(factor(xxx$SurveyCode)))# 19 out of 26
write.csv(xxx, "~/Desktop/coordinates_for_survey_4.csv", row.names = F)
data5 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_4th_batch/DataforREMI_4thbatch.csv")
newdata5 <- data.frame(t(data5[, c(3:ncol(data5))])) # eliminate the first row which contains a comment#
names(newdata5) <- as.character(data5[, 2])#
id <- as.character(data5[, 1])
newdata5[1:10, 1:20]
newdata5[1:10, 1:19]
newdata4[1:10, 1:19]
rm(list = ls())#
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata)), function(i) length(which(newdata[, i] != "P" & newdata[, #
	i] != "-"))) > 0)
newdata[1:10, 1:20]
newdata[1:10, 19:20]
newdata$Latitude[newdata$SurveyCode == "CEND1110605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1110605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "END905605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "END905605"] <- "-6"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009605"] <- "51.25" #
newdata$Longitude[newdata$SurveyCode == "CEND1009605"] <- "-6"#
#
# same here, two different surveys for NMMP 715#
newdata$Latitude[newdata$SurveyCode == "CEND1110715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CEND1110715"] <- "-3.706333"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00715"] <- "53.5" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00715"] <- "-3.706333"#
#
# same for 805, 4 surveys#
newdata$Latitude[newdata$SurveyCode == "CEND1110805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1110805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CEND1009805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CEND1009805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "END905805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "END905805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00805"] <- "54" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00805"] <- "-3.833"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00655"] <- "52.35833" #
newdata$Longitude[newdata$SurveyCode == "CIR4B00655"] <- "-4.17500"#
#
newdata$Latitude[newdata$SurveyCode == "CIR4B00815"] <- "54.066700"#
newdata$Longitude[newdata$SurveyCode == "CIR4B00815"] <- "-5.5"#
# # # # ------------------------------------------- #
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "18A"] <- "52.68467"# CSEMP redesign 18A  34E4(int) 52° 41.08’N   5° 0.73’W#
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07"& newdata$SampleCode == "18A"] <- "-5.012167"#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "53.10417"# 53° 6.25’N     #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "20A"] <- "-4.562667"# 4° 33.76’W#
#
newdata$Latitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "52.31217"# 52° 18.73’N  #
newdata$Longitude[newdata$SurveyCode == "CSEMPCARDI07" & newdata$SampleCode == "10A"] <- "-4.224333"# 4° 13.46’W#
#
# Lune Deep#
newdata$Latitude[newdata$SurveyCode == "LDP96"] <- "53.95389"# 53° 57’ 14”#
newdata$Longitude[newdata$SurveyCode == "LDP96"] <- "-3.097222"# -3° 5’ 50”
data2 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_2.csv", header = F)#
newdata2 <- data.frame(t(data2[, c(4:ncol(data2))]))#
names(newdata2) <- as.character(data2[, 3])#
id <- as.character(data2[, 2])#
#
sapply(c(1:ncol(newdata2)),function(i)class(newdata2[,i]))
newdata2[1:10, 19:20]
newdata2[1:10, 1:20]
for (i in 20:ncol(newdata2)) newdata2[, i] <- as.character(newdata2[, i])#
newdata2$Latitude<- as.character(newdata2$Latitude)#
newdata2$Longitude <- as.character(newdata2$Longitude)#
#
colonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(19:ncol(newdata2)), function(i) length(which(newdata2[, i] != "P" & newdata2[, i] != "-"))) > 0)#
#
length(levels(factor(newdata2$SurveyCode))) # 20 different surveys
names(newdata2)[1:20]
names(newdata)[1:20]
newdata2$TITLE[1:10]
levels(newdata2$TITLE)
newdata2[1:10, 1:20]
data3 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_3rd_batch/DataforREMI_3rd batch.csv", header = F)#
newdata3 <- data.frame(t(data3[, c(3:ncol(data3))]))#
names(newdata3) <- as.character(data3[, 2])#
id <- as.character(data3[, 1])
newdata3[1:10, 1:20]
sapply(c(1:ncol(newdata3)),function(i)class(newdata3[,i]))#
for (i in 19:ncol(newdata3)) newdata3[, i] <- as.character(newdata3[, i])#
newdata3$Latitude<- as.character(newdata3$Latitude)#
newdata3$Longitude <- as.character(newdata3$Longitude)
data4 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_4th_batch/DataforREMI2ndand3rdBatch.csv")#
newdata4 <- data.frame(t(data4[, c(3:ncol(data4))])) # eliminate the first row which contains a comment#
names(newdata4) <- as.character(data4[, 2])#
id <- as.character(data4[, 1])
newdata4[1:10, 1:20]
names(newdata4)[1:20]
names(newdata3)[1:20]
names(newdata)[1:20]
names(newdata2)[1:20]
data4 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_4th_batch/DataforREMI2ndand3rdBatch.csv")#
newdata4 <- data.frame(t(data4[, c(3:ncol(data4))])) # eliminate the first row which contains a comment#
names(newdata4) <- as.character(data4[, 2])#
id <- as.character(data4[, 1])#
#
sapply(c(1:ncol(newdata4)),function(i)class(newdata4[,i]))#
length(levels(factor(newdata4$SurveyCode))) # 50 different surveys#
#
sapply(c(1:ncol(newdata4)),function(i)class(newdata4[,i]))#
for (i in 18:ncol(newdata4)) newdata4[, i] <- as.character(newdata4[, i])#
newdata4$Latitude<- as.character(newdata4$Latitude)#
newdata4$Longitude <- as.character(newdata4$Longitude)
data5 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/data_4th_batch/DataforREMI_4thbatch.csv")#
newdata5 <- data.frame(t(data5[, c(3:ncol(data5))])) # eliminate the first row which contains a comment#
names(newdata5) <- as.character(data5[, 2])#
id <- as.character(data5[, 1])
newdata5[1:10, 1:20]
newdata5[1:10, 1:17]
newdata5[1:10, 1:18]
names(newdata4)[1:20]
names(newdata5)[1:20]
length(levels(factor(newdata5$SurveyCode))) # 50 different surveys
for (i in 18:ncol(newdata5)) newdata5[, i] <- as.character(newdata5[, i])#
newdata5$Latitude<- as.character(newdata5$Latitude)#
newdata5$Longitude <- as.character(newdata5$Longitude)
colonial <- which(sapply(c(18:ncol(newdata5)), function(i) length(which(newdata5[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(18:ncol(newdata5)), function(i) length(which(newdata5[, i] != "P" & newdata4[, i] != ""))) > 0)
colonial <- which(sapply(c(18:ncol(newdata5)), function(i) length(which(newdata5[, i] == "P"))) > 0)#
noncolonial <- which(sapply(c(18:ncol(newdata5)), function(i) length(which(newdata5[, i] != "P" & newdata5[, i] != ""))) > 0)
xx <- newdata5[, c(1:17)] # data.frame(newdata$SurveyCode,newdata$Longitude,newdata$Latitude)#
xxx <- xx[which(as.character(xx$Latitude) == "<null>"), ]#
xxx <- xxx[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title", #
	"StartDate", "SourceName")]
length(levels(factor(xxx$SurveyCode)))# 21 out of 50
xxx
write.csv(xxx, "~/Desktop/coordinates_for_survey_5.csv", row.names = F)
search()
missing2 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/missing_coordinates_surveys/coordinates_for_survey_2.csv")#
missing3 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/missing_coordinates_surveys/coordinates_for_survey_3.csv")#
missing4 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/missing_coordinates_surveys/coordinates_for_survey_4.csv")#
missing5 <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/missing_coordinates_surveys/coordinates_for_survey_5.csv")
names(missing2)
names(missing3)
names(missing4)
names(missing5)
for(i in 1:length(names(missing1))){#
	missing2[, i] <- as.character(missing2[, i])#
	missing3[, i] <- as.character(missing3[, i])#
	missing4[, i] <- as.character(missing4[, i])#
	missing5[, i] <- as.character(missing5[, i])#
}
for(i in 1:length(names(missing2))){#
	missing2[, i] <- as.character(missing2[, i])#
	missing3[, i] <- as.character(missing3[, i])#
	missing4[, i] <- as.character(missing4[, i])#
	missing5[, i] <- as.character(missing5[, i])#
}
rbind(missing2, missing3, missing4, missing5)
data.frame(rbind(missing2, missing3, missing4, missing5))
allmissing <- data.frame(rbind(missing2, missing3, missing4, missing5))
names(allmissing)
head(allmissing)
dim(allmissing)
tail(allmissing)
allmissing <- allmissing[, c("LocationName", "SampleCode", "DateTaken", "AreaName", "StationCode", "SurveyCode", "Title")]
dim(allmissing)
head(allmissing)
data <- read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/abd.csv", header = F)#
#
newdata <- data.frame(t(data[, c(4:ncol(data))]))#
names(newdata) <- as.character(data[, 3])#
id <- as.character(data[, 2])#
#
# from column 19 all are factors. convert into characters to replace all the "P" and all the "-" by 1s and NAs respectively#
for (i in 19:ncol(newdata)) newdata[, i] <- as.character(newdata[, i])#
newdata$Latitude<- as.character(newdata$Latitude)#
newdata$Longitude <- as.character(newdata$Longitude)
newdata[1:10, 1:20]
newdata[1:20, 1:20]
newdata[1:100, 1:20]
newdata[45:65, 1:20]
newdata[45:65, 1]
newdata[45:65, 2]
newdata[1:20, 1:20]
newdata[1:200, 1:20]
newdata[1:500, 1:20]
head(allmissing)
allmissing$SurveyCode
unique(allmissing$SurveyCode)
unique(newdata$SurveyCode)
newdata[newdata$SurveyCode == "CIR4B00715", ]
newdata[newdata$SurveyCode == "CIR4B00715", 1:20]
newdata[newdata$SurveyCode == "CIR4B00715" | newdata$SurveyCode == "CEND1110715", 1:20]
dim(allmissing)
dim(allmissing[!duplicated(allmissing$SampleCode), ])
head(allmissing[!duplicated(allmissing$SampleCode), ])
head(allmissing[!duplicated(allmissing$SurveyCode), ])
dim(allmissing[!duplicated(allmissing$SurveyCode), ])
unique(newdata$SurveyCode)
unique(allmissing$SurveyCode)
write.csv(allmissing[!duplicated(allmissing$SurveyCode), ], "~/Desktop/missing_coordinates.csv", row.names = F)
read.csv("~/Google Drive/not_to_share/my_backup/myDocuments/postdoc/MERP_postdoc/benthos_data/unicorn/missing_coordinates_surveys/missing_coordinates.csv")
list.packages <- c("devtools","roxygen2","testthat","knitr","rmarkdown")#
sapply(c(1:length(list.packages)),function(i){#
	# install.packages(list.packages[i],repos="http://star-www.st-andrews.ac.uk/cran/")#
	library(list.packages[i],character.only=T)#
})
rm(list = ls())#
setwd("~/Google Drive/not_to_share/my_backup/myDocuments/github/rfoodwebs/rfoodwebs_R_package")#
devtools::install("Rfoodwebs",local=FALSE)
library("Rfoodwebs")#
?web_generator_r
data(spelist)#
# load foodweb#
data(fweb)#
data(fctgroup)#
data(cbess_M)#
data(cbess_N)
resA <- createcheddarobj("A")#
resB <- createcheddarobj("B")#
resC <- createcheddarobj("C")#
resD <- createcheddarobj("D")
sys.Time(web_generator_r(as.character(spelist$species.id), fweb))
Sys.Time(web_generator_r(as.character(spelist$species.id), fweb))
system.time(web_generator_r(as.character(spelist$species.id), fweb))
system.time(web_generator_r(as.character(spelist$species.id), fweb))
system.time(web_generator(as.character(spelist$species.id), fweb))
system.time(web_generator(as.character(spelist$species.id), fweb))
setwd("/Users/Remi/Google Drive/not_to_share/my_backup/myDocuments/github/rfoodwebs/rfoodwebs_R_package")#
setwd("Rfoodwebs")#
devtools::document()
